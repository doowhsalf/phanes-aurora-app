{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_server-autorun/server.coffee","meteor://ðŸ’»app/server.coffee"],"names":["module","export","Tracker","link","v","Fiber","default","Future","TrackerInstance","guard","nextId","privateObject","constructor","active","currentComputation","pendingComputations","willFlush","inFlush","inRequireFlush","inCompute","throwFirstError","afterFlushCallbacks","setCurrentComputation","computation","_debugFunc","Meteor","_debug","console","error","apply","arguments","_maybeSuppressMoreLogs","messagesLength","_suppressed_log_expected","_suppress_log","_throwOrLog","from","i","idx","len","message","printArg","printArgs","results","stack","name","indexOf","length","push","_deferAndTransfer","func","defer","assert","current","_trackerInstance","requireFlush","_runFlush","fromRequireFlush","options","finishedTry","recomputedCount","wait","Error","shift","_recompute","_needsRecompute","unshift","finishSynchronously","error1","return","setTimeout","base","_nodeCodeMustBeInFiber","flush","_throwFirstError","autorun","c","Computation","onError","onInvalidate","stop","nonreactive","f","previous","trackerInstance","afterFlush","Object","defineProperties","get","_parent","_onError","_private","errored","onException","stopped","invalidated","firstRun","_id","_onInvalidateCallbacks","_onStopCallbacks","_beforeRunCallbacks","_afterRunCallbacks","_recomputing","_func","bindEnvironment","_compute","FiberUtils","ensure","onStop","beforeRun","afterRun","invalidate","callback","ref","synchronize","_runInside","previousComputation","previousInCompute","previousTrackerInstance","call","run","Dependency","_dependentsById","depend","id","changed","hasDependents"],"mappings":"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","file":"/packages/peerlibrary_server-autorun.js","sourcesContent":["import {Tracker} from 'meteor/tracker'\n\nimport Fiber from 'fibers'\nimport Future from 'fibers/future'\n\n# Tracker.Computation constructor is private, so we are using this object as a guard.\n# External code cannot access this, and will not be able to directly construct a\n# Tracker.Computation instance.\nprivateObject = {}\n\n# Guard object for fiber utils.\nguard = {}\n\nnextId = 1\n\nclass TrackerInstance\n  constructor: ->\n    @active = false\n    @currentComputation = null\n\n    @pendingComputations = []\n    @willFlush = false\n    @inFlush = null\n    @inRequireFlush = false\n    @inCompute = false\n    @throwFirstError = false\n    @afterFlushCallbacks = []\n\n  setCurrentComputation: (computation) ->\n    @currentComputation = computation\n    @active = !!computation\n\n  # Copied from tracker.js.\n  _debugFunc: ->\n    return Meteor._debug if Meteor?._debug\n\n    if console?.error\n      return ->\n        console.error.apply console, arguments\n\n    return ->\n\n  # Copied from tracker.js.\n  _maybeSuppressMoreLogs: (messagesLength) ->\n    if typeof Meteor isnt \"undefined\"\n      if Meteor._suppressed_log_expected()\n        Meteor._suppress_log(messagesLength - 1)\n\n  # Copied from tracker.js.\n  _throwOrLog: (from, error) ->\n    if @throwFirstError\n      throw error\n    else\n      printArgs = [\"Exception from Tracker \" + from + \" function:\"]\n      if error.stack and error.message and error.name\n        idx = error.stack.indexOf error.message\n        if idx < 0 or idx > error.name.length + 2\n          message = error.name + \": \" + error.message\n          printArgs.push message\n      printArgs.push error.stack\n      @_maybeSuppressMoreLogs printArgs.length\n\n      for printArg in printArgs\n        @_debugFunc() printArg\n\n  _deferAndTransfer: (func) ->\n    # Defer execution of a function, which will create a new fiber. Make the resulting\n    # fiber share ownership of the same tracker instance as it will serve only as its\n    # extension for executing its flushes.\n    Meteor.defer =>\n      assert not Fiber.current._trackerInstance\n\n      try\n        Fiber.current._trackerInstance = @\n        func()\n      finally\n        Fiber.current._trackerInstance = null\n\n  requireFlush: ->\n    return if @willFlush\n\n    @_deferAndTransfer =>\n      @_runFlush\n        fromRequireFlush: true\n\n    @willFlush = true\n\n  _runFlush: (options) ->\n    if @inFlush instanceof Future\n      # If there are two runs from requireFlush in sequence, we simply skip the second one, the first\n      # one is still in progress.\n      return if options?.fromRequireFlush\n\n      # We wait for the previous flush from requireFlush to finish before continuing.\n      @inFlush.wait()\n      assert not @inFlush\n\n    # If already in flush and this is a flush from requireFlush, just skip it.\n    return if @inFlush and options?.fromRequireFlush\n\n    throw new Error \"Can't call Tracker.flush while flushing\" if @inFlush\n\n    if @inCompute\n      if options?.fromRequireFlush\n        # If this fiber is currently running a computation and a require flush has been\n        # deferred, we need to defer again and retry.\n        @_deferAndTransfer =>\n          @_runFlush options\n        return\n\n      throw new Error \"Can't flush inside Tracker.autorun\"\n\n    # If this is a run from requireFlush, provide a future so that calls to flush can wait on it.\n    if options?.fromRequireFlush\n      @inFlush = new Future()\n    else\n      @inFlush = true\n\n    @willFlush = true\n    @throwFirstError = !!options?.throwFirstError\n\n    recomputedCount = 0\n    finishedTry = false\n    try\n      while @pendingComputations.length or @afterFlushCallbacks.length\n\n        while @pendingComputations.length\n          computation = @pendingComputations.shift()\n          computation._recompute()\n          if computation._needsRecompute()\n            @pendingComputations.unshift computation\n\n          if not options?.finishSynchronously and ++recomputedCount > 1000\n            finishedTry = true\n            return\n\n        if @afterFlushCallbacks.length\n          func = @afterFlushCallbacks.shift()\n          try\n            func()\n          catch error\n            @_throwOrLog \"afterFlush\", error\n\n      finishedTry = true\n    finally\n      # We first have to set @inFlush to null, then we can return.\n\n      inFlush = @inFlush\n      unless finishedTry\n        @inFlush = null\n        inFlush.return() if inFlush instanceof Future\n        @_runFlush\n          finishSynchronously: options?.finishSynchronously\n          throwFirstError: false\n\n      @willFlush = false\n      @inFlush = null\n      inFlush.return() if inFlush instanceof Future\n      if @pendingComputations.length or @afterFlushCallbacks.length\n        throw new Error \"still have more to do?\" if options?.finishSynchronously\n        Meteor.setTimeout =>\n          @requireFlush()\n        ,\n          10 # ms\n\nTracker._trackerInstance = ->\n  Meteor._nodeCodeMustBeInFiber()\n  Fiber.current._trackerInstance ?= new TrackerInstance()\n\nTracker.flush = (options) ->\n  Tracker._trackerInstance()._runFlush\n    finishSynchronously: true\n    throwFirstError: options?._throwFirstError\n\nTracker.inFlush = ->\n  Tracker._trackerInstance().inFlush\n\nTracker.autorun = (func, options) ->\n  throw new Error \"Tracker.autorun requires a function argument\" unless typeof func is \"function\"\n\n  c = new Tracker.Computation func, Tracker.currentComputation, options?.onError, privateObject\n\n  if Tracker.active\n    Tracker.onInvalidate ->\n      c.stop()\n\n  c\n\nTracker.nonreactive = (f) ->\n  trackerInstance = Tracker._trackerInstance()\n  previous = trackerInstance.currentComputation\n  trackerInstance.setCurrentComputation null\n  try\n    return f()\n  finally\n    trackerInstance.setCurrentComputation previous\n\nTracker.onInvalidate = (f) ->\n  throw new Error \"Tracker.onInvalidate requires a currentComputation\" unless Tracker.active\n\n  Tracker.currentComputation.onInvalidate f\n\nTracker.afterFlush = (f) ->\n  trackerInstance = Tracker._trackerInstance()\n  trackerInstance.afterFlushCallbacks.push f\n  trackerInstance.requireFlush()\n\n# Compatibility with the client-side Tracker. On node.js we can use defineProperties to define getters.\nObject.defineProperties Tracker,\n  currentComputation:\n    get: ->\n      Tracker._trackerInstance().currentComputation\n\n  active:\n    get: ->\n      Tracker._trackerInstance().active\n\nclass Tracker.Computation\n  constructor: (func, @_parent, @_onError, _private) ->\n    throw new Error \"Tracker.Computation constructor is private; use Tracker.autorun\" if _private isnt privateObject\n\n    @stopped = false\n    @invalidated = false\n    @firstRun = true\n    @_id = nextId++\n    @_onInvalidateCallbacks = []\n    @_onStopCallbacks = []\n    @_beforeRunCallbacks = []\n    @_afterRunCallbacks = []\n    @_recomputing = false\n\n    @_trackerInstance = Tracker._trackerInstance()\n\n    onException = (error) =>\n      throw error if @firstRun\n\n      if @_onError\n        @_onError error\n      else\n        @_trackerInstance._throwOrLog \"recompute\", error\n\n    @_func = Meteor.bindEnvironment func, onException, @\n\n    errored = true\n    try\n      @_compute()\n      errored = false\n    finally\n      @firstRun = false\n      @stop() if errored\n\n  onInvalidate: (f) ->\n    FiberUtils.ensure =>\n      throw new Error \"onInvalidate requires a function\" unless typeof f is \"function\"\n\n      if @invalidated\n        Tracker.nonreactive =>\n          f @\n      else\n        @_onInvalidateCallbacks.push f\n\n  onStop: (f) ->\n    FiberUtils.ensure =>\n      throw new Error \"onStop requires a function\" unless typeof f is \"function\"\n\n      if @stopped\n        Tracker.nonreactive =>\n          f @\n      else\n        @_onStopCallbacks.push f\n\n  beforeRun: (f) ->\n    throw new Error \"beforeRun requires a function\" unless typeof f is \"function\"\n\n    @_beforeRunCallbacks.push f\n\n  afterRun: (f) ->\n    throw new Error \"afterRun requires a function\" unless typeof f is \"function\"\n\n    @_afterRunCallbacks.push f\n\n  invalidate: ->\n    FiberUtils.ensure =>\n      # TODO: Why some tests freeze if we wrap this method into FiberUtils.synchronize?\n      if not @invalidated\n        if not @_recomputing and not @stopped\n          @_trackerInstance.requireFlush()\n          @_trackerInstance.pendingComputations.push @\n\n        @invalidated = true\n\n        for callback in @_onInvalidateCallbacks\n          Tracker.nonreactive =>\n            callback @\n        @_onInvalidateCallbacks = []\n\n  stop: ->\n    FiberUtils.ensure =>\n      FiberUtils.synchronize guard, @_id, =>\n        return if @stopped\n        @stopped = true\n\n        @invalidate()\n\n        while @_onStopCallbacks.length\n          callback = @_onStopCallbacks.shift()\n          Tracker.nonreactive =>\n            callback @\n\n  # Runs an arbitrary function inside the computation. This allows breaking many assumptions, so use it very carefully.\n  _runInside: (func) ->\n    FiberUtils.synchronize guard, @_id, =>\n      Meteor._nodeCodeMustBeInFiber()\n      previousTrackerInstance = Tracker._trackerInstance()\n      Fiber.current._trackerInstance = @_trackerInstance\n      previousComputation = @_trackerInstance.currentComputation\n      @_trackerInstance.setCurrentComputation @\n      previousInCompute = @_trackerInstance.inCompute\n      @_trackerInstance.inCompute = true\n      try\n        func @\n      finally\n        Fiber.current._trackerInstance = previousTrackerInstance\n        @_trackerInstance.setCurrentComputation previousComputation\n        @_trackerInstance.inCompute = previousInCompute\n\n  _compute: ->\n    FiberUtils.synchronize guard, @_id, =>\n      @invalidated = false\n\n      @_runInside (computation) =>\n        while @_beforeRunCallbacks.length\n          callback = @_beforeRunCallbacks.shift()\n          Tracker.nonreactive =>\n            callback @\n\n        @_func.call null, @\n\n        while @_afterRunCallbacks.length\n          callback = @_afterRunCallbacks.shift()\n          Tracker.nonreactive =>\n            callback @\n\n  _needsRecompute: ->\n    @invalidated and not @stopped\n\n  _recompute: ->\n    FiberUtils.synchronize guard, @_id, =>\n      assert not @_recomputing\n      @_recomputing = true\n      try\n        if @_needsRecompute()\n          @_compute()\n      finally\n        @_recomputing = false\n\n  flush: ->\n    FiberUtils.ensure =>\n      return if @_recomputing\n\n      @_recompute()\n\n  run: ->\n    FiberUtils.ensure =>\n      @invalidate()\n      @flush()\n\nclass Tracker.Dependency\n  constructor: ->\n    @_dependentsById = {}\n\n  depend: (computation) ->\n    unless computation\n      return false unless Tracker.active\n      computation = Tracker.currentComputation\n\n    id = computation._id\n\n    if id not of @_dependentsById\n      @_dependentsById[id] = computation\n      computation.onInvalidate =>\n        delete @_dependentsById[id]\n      return true\n\n    false\n\n  changed: ->\n    for id, computation of @_dependentsById\n      computation.invalidate()\n\n  hasDependents: ->\n    for id, computation of @_dependentsById\n      return true\n    false\n\nexport {Tracker}\n","var TrackerInstance, guard, nextId, privateObject;\n\nimport {\n  Tracker\n} from 'meteor/tracker';\n\nimport Fiber from 'fibers';\n\nimport Future from 'fibers/future';\n\n// Tracker.Computation constructor is private, so we are using this object as a guard.\n// External code cannot access this, and will not be able to directly construct a\n// Tracker.Computation instance.\nprivateObject = {};\n\n// Guard object for fiber utils.\nguard = {};\n\nnextId = 1;\n\nTrackerInstance = class TrackerInstance {\n  constructor() {\n    this.active = false;\n    this.currentComputation = null;\n    this.pendingComputations = [];\n    this.willFlush = false;\n    this.inFlush = null;\n    this.inRequireFlush = false;\n    this.inCompute = false;\n    this.throwFirstError = false;\n    this.afterFlushCallbacks = [];\n  }\n\n  setCurrentComputation(computation) {\n    this.currentComputation = computation;\n    return this.active = !!computation;\n  }\n\n  // Copied from tracker.js.\n  _debugFunc() {\n    if (typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor._debug : void 0) {\n      return Meteor._debug;\n    }\n    if (typeof console !== \"undefined\" && console !== null ? console.error : void 0) {\n      return function() {\n        return console.error.apply(console, arguments);\n      };\n    }\n    return function() {};\n  }\n\n  // Copied from tracker.js.\n  _maybeSuppressMoreLogs(messagesLength) {\n    if (typeof Meteor !== \"undefined\") {\n      if (Meteor._suppressed_log_expected()) {\n        return Meteor._suppress_log(messagesLength - 1);\n      }\n    }\n  }\n\n  // Copied from tracker.js.\n  _throwOrLog(from, error) {\n    var i, idx, len, message, printArg, printArgs, results;\n    if (this.throwFirstError) {\n      throw error;\n    } else {\n      printArgs = [\"Exception from Tracker \" + from + \" function:\"];\n      if (error.stack && error.message && error.name) {\n        idx = error.stack.indexOf(error.message);\n        if (idx < 0 || idx > error.name.length + 2) {\n          message = error.name + \": \" + error.message;\n          printArgs.push(message);\n        }\n      }\n      printArgs.push(error.stack);\n      this._maybeSuppressMoreLogs(printArgs.length);\n      results = [];\n      for (i = 0, len = printArgs.length; i < len; i++) {\n        printArg = printArgs[i];\n        results.push(this._debugFunc()(printArg));\n      }\n      return results;\n    }\n  }\n\n  _deferAndTransfer(func) {\n    // Defer execution of a function, which will create a new fiber. Make the resulting\n    // fiber share ownership of the same tracker instance as it will serve only as its\n    // extension for executing its flushes.\n    return Meteor.defer(() => {\n      assert(!Fiber.current._trackerInstance);\n      try {\n        Fiber.current._trackerInstance = this;\n        return func();\n      } finally {\n        Fiber.current._trackerInstance = null;\n      }\n    });\n  }\n\n  requireFlush() {\n    if (this.willFlush) {\n      return;\n    }\n    this._deferAndTransfer(() => {\n      return this._runFlush({\n        fromRequireFlush: true\n      });\n    });\n    return this.willFlush = true;\n  }\n\n  _runFlush(options) {\n    var computation, error, finishedTry, func, inFlush, recomputedCount;\n    if (this.inFlush instanceof Future) {\n      // If there are two runs from requireFlush in sequence, we simply skip the second one, the first\n      // one is still in progress.\n      if (options != null ? options.fromRequireFlush : void 0) {\n        return;\n      }\n      // We wait for the previous flush from requireFlush to finish before continuing.\n      this.inFlush.wait();\n      assert(!this.inFlush);\n    }\n    // If already in flush and this is a flush from requireFlush, just skip it.\n    if (this.inFlush && (options != null ? options.fromRequireFlush : void 0)) {\n      return;\n    }\n    if (this.inFlush) {\n      throw new Error(\"Can't call Tracker.flush while flushing\");\n    }\n    if (this.inCompute) {\n      if (options != null ? options.fromRequireFlush : void 0) {\n        // If this fiber is currently running a computation and a require flush has been\n        // deferred, we need to defer again and retry.\n        this._deferAndTransfer(() => {\n          return this._runFlush(options);\n        });\n        return;\n      }\n      throw new Error(\"Can't flush inside Tracker.autorun\");\n    }\n    // If this is a run from requireFlush, provide a future so that calls to flush can wait on it.\n    if (options != null ? options.fromRequireFlush : void 0) {\n      this.inFlush = new Future();\n    } else {\n      this.inFlush = true;\n    }\n    this.willFlush = true;\n    this.throwFirstError = !!(options != null ? options.throwFirstError : void 0);\n    recomputedCount = 0;\n    finishedTry = false;\n    try {\n      while (this.pendingComputations.length || this.afterFlushCallbacks.length) {\n        while (this.pendingComputations.length) {\n          computation = this.pendingComputations.shift();\n          computation._recompute();\n          if (computation._needsRecompute()) {\n            this.pendingComputations.unshift(computation);\n          }\n          if (!(options != null ? options.finishSynchronously : void 0) && ++recomputedCount > 1000) {\n            finishedTry = true;\n            return;\n          }\n        }\n        if (this.afterFlushCallbacks.length) {\n          func = this.afterFlushCallbacks.shift();\n          try {\n            func();\n          } catch (error1) {\n            error = error1;\n            this._throwOrLog(\"afterFlush\", error);\n          }\n        }\n      }\n      return finishedTry = true;\n    } finally {\n      // We first have to set @inFlush to null, then we can return.\n      inFlush = this.inFlush;\n      if (!finishedTry) {\n        this.inFlush = null;\n        if (inFlush instanceof Future) {\n          inFlush.return();\n        }\n        this._runFlush({\n          finishSynchronously: options != null ? options.finishSynchronously : void 0,\n          throwFirstError: false\n        });\n      }\n      this.willFlush = false;\n      this.inFlush = null;\n      if (inFlush instanceof Future) {\n        inFlush.return();\n      }\n      if (this.pendingComputations.length || this.afterFlushCallbacks.length) {\n        if (options != null ? options.finishSynchronously : void 0) {\n          throw new Error(\"still have more to do?\");\n        }\n        Meteor.setTimeout(() => {\n          return this.requireFlush();\n        }, 10); // ms\n      }\n    }\n  }\n\n};\n\nTracker._trackerInstance = function() {\n  var base;\n  Meteor._nodeCodeMustBeInFiber();\n  return (base = Fiber.current)._trackerInstance != null ? base._trackerInstance : base._trackerInstance = new TrackerInstance();\n};\n\nTracker.flush = function(options) {\n  return Tracker._trackerInstance()._runFlush({\n    finishSynchronously: true,\n    throwFirstError: options != null ? options._throwFirstError : void 0\n  });\n};\n\nTracker.inFlush = function() {\n  return Tracker._trackerInstance().inFlush;\n};\n\nTracker.autorun = function(func, options) {\n  var c;\n  if (typeof func !== \"function\") {\n    throw new Error(\"Tracker.autorun requires a function argument\");\n  }\n  c = new Tracker.Computation(func, Tracker.currentComputation, options != null ? options.onError : void 0, privateObject);\n  if (Tracker.active) {\n    Tracker.onInvalidate(function() {\n      return c.stop();\n    });\n  }\n  return c;\n};\n\nTracker.nonreactive = function(f) {\n  var previous, trackerInstance;\n  trackerInstance = Tracker._trackerInstance();\n  previous = trackerInstance.currentComputation;\n  trackerInstance.setCurrentComputation(null);\n  try {\n    return f();\n  } finally {\n    trackerInstance.setCurrentComputation(previous);\n  }\n};\n\nTracker.onInvalidate = function(f) {\n  if (!Tracker.active) {\n    throw new Error(\"Tracker.onInvalidate requires a currentComputation\");\n  }\n  return Tracker.currentComputation.onInvalidate(f);\n};\n\nTracker.afterFlush = function(f) {\n  var trackerInstance;\n  trackerInstance = Tracker._trackerInstance();\n  trackerInstance.afterFlushCallbacks.push(f);\n  return trackerInstance.requireFlush();\n};\n\n// Compatibility with the client-side Tracker. On node.js we can use defineProperties to define getters.\nObject.defineProperties(Tracker, {\n  currentComputation: {\n    get: function() {\n      return Tracker._trackerInstance().currentComputation;\n    }\n  },\n  active: {\n    get: function() {\n      return Tracker._trackerInstance().active;\n    }\n  }\n});\n\nTracker.Computation = class Computation {\n  constructor(func, _parent, _onError, _private) {\n    var errored, onException;\n    this._parent = _parent;\n    this._onError = _onError;\n    if (_private !== privateObject) {\n      throw new Error(\"Tracker.Computation constructor is private; use Tracker.autorun\");\n    }\n    this.stopped = false;\n    this.invalidated = false;\n    this.firstRun = true;\n    this._id = nextId++;\n    this._onInvalidateCallbacks = [];\n    this._onStopCallbacks = [];\n    this._beforeRunCallbacks = [];\n    this._afterRunCallbacks = [];\n    this._recomputing = false;\n    this._trackerInstance = Tracker._trackerInstance();\n    onException = (error) => {\n      if (this.firstRun) {\n        throw error;\n      }\n      if (this._onError) {\n        return this._onError(error);\n      } else {\n        return this._trackerInstance._throwOrLog(\"recompute\", error);\n      }\n    };\n    this._func = Meteor.bindEnvironment(func, onException, this);\n    errored = true;\n    try {\n      this._compute();\n      errored = false;\n    } finally {\n      this.firstRun = false;\n      if (errored) {\n        this.stop();\n      }\n    }\n  }\n\n  onInvalidate(f) {\n    return FiberUtils.ensure(() => {\n      if (typeof f !== \"function\") {\n        throw new Error(\"onInvalidate requires a function\");\n      }\n      if (this.invalidated) {\n        return Tracker.nonreactive(() => {\n          return f(this);\n        });\n      } else {\n        return this._onInvalidateCallbacks.push(f);\n      }\n    });\n  }\n\n  onStop(f) {\n    return FiberUtils.ensure(() => {\n      if (typeof f !== \"function\") {\n        throw new Error(\"onStop requires a function\");\n      }\n      if (this.stopped) {\n        return Tracker.nonreactive(() => {\n          return f(this);\n        });\n      } else {\n        return this._onStopCallbacks.push(f);\n      }\n    });\n  }\n\n  beforeRun(f) {\n    if (typeof f !== \"function\") {\n      throw new Error(\"beforeRun requires a function\");\n    }\n    return this._beforeRunCallbacks.push(f);\n  }\n\n  afterRun(f) {\n    if (typeof f !== \"function\") {\n      throw new Error(\"afterRun requires a function\");\n    }\n    return this._afterRunCallbacks.push(f);\n  }\n\n  invalidate() {\n    return FiberUtils.ensure(() => {\n      var callback, i, len, ref;\n      // TODO: Why some tests freeze if we wrap this method into FiberUtils.synchronize?\n      if (!this.invalidated) {\n        if (!this._recomputing && !this.stopped) {\n          this._trackerInstance.requireFlush();\n          this._trackerInstance.pendingComputations.push(this);\n        }\n        this.invalidated = true;\n        ref = this._onInvalidateCallbacks;\n        for (i = 0, len = ref.length; i < len; i++) {\n          callback = ref[i];\n          Tracker.nonreactive(() => {\n            return callback(this);\n          });\n        }\n        return this._onInvalidateCallbacks = [];\n      }\n    });\n  }\n\n  stop() {\n    return FiberUtils.ensure(() => {\n      return FiberUtils.synchronize(guard, this._id, () => {\n        var callback, results;\n        if (this.stopped) {\n          return;\n        }\n        this.stopped = true;\n        this.invalidate();\n        results = [];\n        while (this._onStopCallbacks.length) {\n          callback = this._onStopCallbacks.shift();\n          results.push(Tracker.nonreactive(() => {\n            return callback(this);\n          }));\n        }\n        return results;\n      });\n    });\n  }\n\n  // Runs an arbitrary function inside the computation. This allows breaking many assumptions, so use it very carefully.\n  _runInside(func) {\n    return FiberUtils.synchronize(guard, this._id, () => {\n      var previousComputation, previousInCompute, previousTrackerInstance;\n      Meteor._nodeCodeMustBeInFiber();\n      previousTrackerInstance = Tracker._trackerInstance();\n      Fiber.current._trackerInstance = this._trackerInstance;\n      previousComputation = this._trackerInstance.currentComputation;\n      this._trackerInstance.setCurrentComputation(this);\n      previousInCompute = this._trackerInstance.inCompute;\n      this._trackerInstance.inCompute = true;\n      try {\n        return func(this);\n      } finally {\n        Fiber.current._trackerInstance = previousTrackerInstance;\n        this._trackerInstance.setCurrentComputation(previousComputation);\n        this._trackerInstance.inCompute = previousInCompute;\n      }\n    });\n  }\n\n  _compute() {\n    return FiberUtils.synchronize(guard, this._id, () => {\n      this.invalidated = false;\n      return this._runInside((computation) => {\n        var callback, results;\n        while (this._beforeRunCallbacks.length) {\n          callback = this._beforeRunCallbacks.shift();\n          Tracker.nonreactive(() => {\n            return callback(this);\n          });\n        }\n        this._func.call(null, this);\n        results = [];\n        while (this._afterRunCallbacks.length) {\n          callback = this._afterRunCallbacks.shift();\n          results.push(Tracker.nonreactive(() => {\n            return callback(this);\n          }));\n        }\n        return results;\n      });\n    });\n  }\n\n  _needsRecompute() {\n    return this.invalidated && !this.stopped;\n  }\n\n  _recompute() {\n    return FiberUtils.synchronize(guard, this._id, () => {\n      assert(!this._recomputing);\n      this._recomputing = true;\n      try {\n        if (this._needsRecompute()) {\n          return this._compute();\n        }\n      } finally {\n        this._recomputing = false;\n      }\n    });\n  }\n\n  flush() {\n    return FiberUtils.ensure(() => {\n      if (this._recomputing) {\n        return;\n      }\n      return this._recompute();\n    });\n  }\n\n  run() {\n    return FiberUtils.ensure(() => {\n      this.invalidate();\n      return this.flush();\n    });\n  }\n\n};\n\nTracker.Dependency = class Dependency {\n  constructor() {\n    this._dependentsById = {};\n  }\n\n  depend(computation) {\n    var id;\n    if (!computation) {\n      if (!Tracker.active) {\n        return false;\n      }\n      computation = Tracker.currentComputation;\n    }\n    id = computation._id;\n    if (!(id in this._dependentsById)) {\n      this._dependentsById[id] = computation;\n      computation.onInvalidate(() => {\n        return delete this._dependentsById[id];\n      });\n      return true;\n    }\n    return false;\n  }\n\n  changed() {\n    var computation, id, ref, results;\n    ref = this._dependentsById;\n    results = [];\n    for (id in ref) {\n      computation = ref[id];\n      results.push(computation.invalidate());\n    }\n    return results;\n  }\n\n  hasDependents() {\n    var computation, id, ref;\n    ref = this._dependentsById;\n    for (id in ref) {\n      computation = ref[id];\n      return true;\n    }\n    return false;\n  }\n\n};\n\nexport {\n  Tracker\n};\n"]}
{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_reactive-publish/server.coffee","meteor://ðŸ’»app/server.coffee"],"names":["Fiber","checkNames","getCollectionNames","iterateObjectOrMapKeys","originalLocalCollectionCursorObserveChanges","originalObserveChanges","wrapCallbacks","indexOf","Npm","require","result","cursor","resultNames","_","isArray","i","len","results","length","isObject","push","_getCollectionName","publish","allCollectionNames","id","collectionNames","collectionName","computationId","names","call","error","Error","objectOrMap","fn","key","results1","x","Map","callbacks","initializingReference","callback","callbackName","currentComputation","Tracker","active","Meteor","_nodeCodeMustBeInFiber","clone","args","previousPublishComputation","initializing","current","_publishComputation","apply","MongoInternals","Connection","prototype","_observeChanges","cursorDescription","ordered","handle","LocalCollection","Cursor","observeChanges","options","extendPublish","name","publishFunction","newPublishFunction","documents","handles","oldDocuments","originalAdded","originalReady","ready","_currentComputation","_installCallbacks","computation","_publishOnStopSet","onStop","_id","_publishAfterRunSet","afterRun","_documents","currentComputationAddedDocumentIds","currentlyPublishedDocumentIds","docs","otherComputationsAddedDocumentsIds","otherComputationsPreviouslyAddedDocumentsIds","ref","ref1","Array","from","get","keys","union","difference","removed","_idFilter","idParse","beforeRun","_trackerInstance","requireFlush","added","fields","dataByKey","oldFields","ref2","ref3","ref4","ref5","stringId","idStringify","_ensure","has","_session","getCollectionView","field","changed","extend","autorun","runFunc","onInvalidate","error1","stop","firstRun","Computation","_isDeactivated","_publishHandlerResult","shift"],"mappings":"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","file":"/packages/peerlibrary_reactive-publish.js","sourcesContent":["Fiber = Npm.require 'fibers'\n\ngetCollectionNames = (result) ->\n  if result and _.isArray result\n    resultNames = (cursor._getCollectionName() for cursor in result when _.isObject(cursor) and '_getCollectionName' of cursor)\n  else if result and _.isObject(result) and '_getCollectionName' of result\n    resultNames = [result._getCollectionName()]\n  else\n    resultNames = []\n\n  resultNames\n\ncheckNames = (publish, allCollectionNames, id, collectionNames) ->\n  for computationId, names of allCollectionNames when computationId isnt id\n    for collectionName in names when collectionName in collectionNames\n      publish.error new Error \"Multiple cursors for collection '#{collectionName}'\"\n      return false\n\n  true\n\niterateObjectOrMapKeys = (objectOrMap, fn) ->\n  if (objectOrMap instanceof Map)\n    for [ key ] from objectOrMap\n      fn(key)\n  else\n    for key of objectOrMap\n      fn(key)\n\nwrapCallbacks = (callbacks, initializingReference) ->\n  # If observeChanges is called inside a reactive context we have to make extra effort to pass the computation to the\n  # observeChanges callbacks so that the computation is available to the \"added\" publish method, if it is called. We use\n  # fiber object for that. observeChanges callbacks are not called in a reactive context. Additionally, we want this to\n  # be passed only during the observeChanges initialization (when it is calling \"added\" callbacks in a blocking manner).\n  if Tracker.active\n    Meteor._nodeCodeMustBeInFiber()\n    currentComputation = Tracker.currentComputation\n    callbacks = _.clone callbacks\n    for callbackName, callback of callbacks when callbackName in ['added', 'changed', 'removed', 'addedBefore', 'movedBefore']\n      do (callbackName, callback) ->\n        callbacks[callbackName] = (args...) ->\n          if initializingReference.initializing\n            previousPublishComputation = Fiber.current._publishComputation\n            Fiber.current._publishComputation = currentComputation\n            try\n              callback.apply null, args\n            finally\n              Fiber.current._publishComputation = previousPublishComputation\n          else\n            callback.apply null, args\n\n  callbacks\n\noriginalObserveChanges = MongoInternals.Connection::_observeChanges\nMongoInternals.Connection::_observeChanges = (cursorDescription, ordered, callbacks) ->\n  initializing = true\n\n  callbacks = wrapCallbacks callbacks, initializing: initializing\n\n  handle = originalObserveChanges.call @, cursorDescription, ordered, callbacks\n  initializing = false\n  handle\n\noriginalLocalCollectionCursorObserveChanges = LocalCollection.Cursor::observeChanges\nLocalCollection.Cursor::observeChanges = (options) ->\n  initializing = true\n\n  options = wrapCallbacks options, initializing: initializing\n\n  handle = originalLocalCollectionCursorObserveChanges.call @, options\n  initializing = false\n  handle\n\nextendPublish (name, publishFunction, options) ->\n  newPublishFunction = (args...) ->\n    publish = @\n\n    oldDocuments = {}\n    documents = {}\n\n    allCollectionNames = {}\n\n    publish._currentComputation = ->\n      if Tracker.active\n        return Tracker.currentComputation\n      else\n        # Computation can also be passed through current fiber in the case the \"added\" method is called\n        # from the observeChanges callback from an observeChanges called inside a reactive context.\n        return Fiber.current._publishComputation\n\n      null\n\n    publish._installCallbacks = ->\n      computation = @_currentComputation()\n\n      return unless computation\n\n      unless computation._publishOnStopSet\n        computation._publishOnStopSet = true\n\n        computation.onStop =>\n          delete oldDocuments[computation._id]\n          delete documents[computation._id]\n\n      unless computation._publishAfterRunSet\n        computation._publishAfterRunSet = true\n\n        computation.afterRun =>\n          # We remove those which are not published anymore.\n          iterateObjectOrMapKeys @_documents, (collectionName) =>\n            if @_documents instanceof Map\n              currentlyPublishedDocumentIds = Array.from(@_documents.get(collectionName))\n            else\n              currentlyPublishedDocumentIds = _.keys(@_documents[collectionName] or {})\n\n            currentComputationAddedDocumentIds = _.keys(documents[computation._id]?[collectionName] or {})\n            # If afterRun for other autoruns in the publish function have not yet run, we have to look in \"documents\" as well.\n            otherComputationsAddedDocumentsIds = _.union (_.keys(docs[collectionName] or {}) for computationId, docs of documents when computationId isnt \"#{computation._id}\")...\n            # But after afterRun, \"documents\" is empty to be ready for next rerun of the computation, so we look into \"oldDocuments\".\n            otherComputationsPreviouslyAddedDocumentsIds = _.union (_.keys(docs[collectionName] or {}) for computationId, docs of oldDocuments when computationId isnt \"#{computation._id}\")...\n\n            # We ignore IDs found in both otherComputationsAddedDocumentsIds and otherComputationsPreviouslyAddedDocumentsIds\n            # which might ignore more IDs then necessary (an ID might be previously added which has not been added in this\n            # iteration) but this is OK because in afterRun of other computations this will be corrected and documents\n            # with those IDs removed.\n            for id in _.difference currentlyPublishedDocumentIds, currentComputationAddedDocumentIds, otherComputationsAddedDocumentsIds, otherComputationsPreviouslyAddedDocumentsIds\n              @removed collectionName, @_idFilter.idParse id\n\n          computation.beforeRun =>\n            oldDocuments[computation._id] = documents[computation._id] or {}\n            documents[computation._id] = {}\n\n          computation._publishAfterRunSet = false\n\n        computation._trackerInstance.requireFlush()\n\n      return\n\n    originalAdded = publish.added\n    publish.added = (collectionName, id, fields) ->\n      stringId = @_idFilter.idStringify id\n\n      @_installCallbacks()\n\n      currentComputation = @_currentComputation()\n      Meteor._ensure(documents, currentComputation._id, collectionName)[stringId] = true if currentComputation\n\n      # If document as already present in publish then we call changed to send updated fields (Meteor sends only a diff).\n      # This can hide some errors in publish functions if they one calls \"added\" on an existing document and we could\n      # make it so that this behavior works only inside reactive computation (if \"currentComputation\" is set), but we\n      # can also make it so that publish function tries to do something smarter (sending a diff) in all cases, as we do.\n      if ((@_documents instanceof Map && @_documents.get(collectionName)?.has(stringId)) || @_documents[collectionName]?[stringId])\n        oldFields = {}\n        # If some field existed before, but does not exist anymore, we have to remove it by calling \"changed\"\n        # with value set to \"undefined\". So we look into current session's state and see which fields are currently\n        # known and create an object of same fields, just all values set to \"undefined\". We then override some fields\n        # with new values. Only top-level fields matter.\n        _documents = @_session?.getCollectionView(collectionName)?.documents or {}\n        if _documents instanceof Map\n          dataByKey = _documents.get(stringId)?.dataByKey or {}\n        else\n          dataByKey = _documents?[stringId]?.dataByKey or {}\n\n        iterateObjectOrMapKeys dataByKey, (field) =>\n          oldFields[field] = undefined\n\n        @changed collectionName, id, _.extend oldFields, fields\n      else\n        originalAdded.call @, collectionName, id, fields\n\n    ready = false\n\n    originalReady = publish.ready\n    publish.ready = ->\n      @_installCallbacks()\n\n      # Mark it as ready only the first time.\n      originalReady.call @ unless ready\n      ready = true\n\n      # To return nothing.\n      return\n\n    handles = []\n    # This autorun is nothing special, just that it makes sure handles are stopped when publish stops,\n    # and that you can return cursors from the function which would be automatically published.\n    publish.autorun = (runFunc) ->\n      handle = Tracker.autorun (computation) ->\n        computation.onInvalidate ->\n          delete allCollectionNames[computation._id]\n\n        try\n          result = runFunc.call publish, computation\n        catch error\n          computation.stop()\n\n          if computation.firstRun\n            throw error\n          else\n            publish.error(error)\n            return\n\n        collectionNames = getCollectionNames result\n        allCollectionNames[computation._id] = collectionNames\n\n        unless checkNames publish, allCollectionNames, \"#{computation._id}\", collectionNames\n          computation.stop()\n          return\n\n        # Specially handle if computation has been returned.\n        if result instanceof Tracker.Computation\n          if publish._isDeactivated()\n            result.stop()\n          else\n            handles.push result\n        else\n          publish._publishHandlerResult result unless publish._isDeactivated()\n\n      if publish._isDeactivated()\n        handle.stop()\n      else\n        handles.push handle\n\n      handle\n\n    publish.onStop ->\n      while handles.length\n        handle = handles.shift()\n        handle?.stop()\n\n    result = publishFunction.apply publish, args\n\n    collectionNames = getCollectionNames result\n    allCollectionNames[''] = collectionNames\n    return unless checkNames publish, allCollectionNames, '', collectionNames\n\n    # Specially handle if computation has been returned.\n    if result instanceof Tracker.Computation\n      if publish._isDeactivated()\n        result.stop()\n      else\n        handles.push result\n\n      # Do not return anything.\n      return\n\n    else\n      result\n\n  [name, newPublishFunction, options]\n","var Fiber, checkNames, getCollectionNames, iterateObjectOrMapKeys, originalLocalCollectionCursorObserveChanges, originalObserveChanges, wrapCallbacks,\n  indexOf = [].indexOf;\n\nFiber = Npm.require('fibers');\n\ngetCollectionNames = function(result) {\n  var cursor, resultNames;\n  if (result && _.isArray(result)) {\n    resultNames = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = result.length; i < len; i++) {\n        cursor = result[i];\n        if (_.isObject(cursor) && '_getCollectionName' in cursor) {\n          results.push(cursor._getCollectionName());\n        }\n      }\n      return results;\n    })();\n  } else if (result && _.isObject(result) && '_getCollectionName' in result) {\n    resultNames = [result._getCollectionName()];\n  } else {\n    resultNames = [];\n  }\n  return resultNames;\n};\n\ncheckNames = function(publish, allCollectionNames, id, collectionNames) {\n  var collectionName, computationId, i, len, names;\n  for (computationId in allCollectionNames) {\n    names = allCollectionNames[computationId];\n    if (computationId !== id) {\n      for (i = 0, len = names.length; i < len; i++) {\n        collectionName = names[i];\n        if (!(indexOf.call(collectionNames, collectionName) >= 0)) {\n          continue;\n        }\n        publish.error(new Error(`Multiple cursors for collection '${collectionName}'`));\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\niterateObjectOrMapKeys = function(objectOrMap, fn) {\n  var key, results, results1, x;\n  if (objectOrMap instanceof Map) {\n    results = [];\n    for (x of objectOrMap) {\n      [key] = x;\n      results.push(fn(key));\n    }\n    return results;\n  } else {\n    results1 = [];\n    for (key in objectOrMap) {\n      results1.push(fn(key));\n    }\n    return results1;\n  }\n};\n\nwrapCallbacks = function(callbacks, initializingReference) {\n  var callback, callbackName, currentComputation;\n  // If observeChanges is called inside a reactive context we have to make extra effort to pass the computation to the\n  // observeChanges callbacks so that the computation is available to the \"added\" publish method, if it is called. We use\n  // fiber object for that. observeChanges callbacks are not called in a reactive context. Additionally, we want this to\n  // be passed only during the observeChanges initialization (when it is calling \"added\" callbacks in a blocking manner).\n  if (Tracker.active) {\n    Meteor._nodeCodeMustBeInFiber();\n    currentComputation = Tracker.currentComputation;\n    callbacks = _.clone(callbacks);\n    for (callbackName in callbacks) {\n      callback = callbacks[callbackName];\n      if (callbackName === 'added' || callbackName === 'changed' || callbackName === 'removed' || callbackName === 'addedBefore' || callbackName === 'movedBefore') {\n        (function(callbackName, callback) {\n          return callbacks[callbackName] = function(...args) {\n            var previousPublishComputation;\n            if (initializingReference.initializing) {\n              previousPublishComputation = Fiber.current._publishComputation;\n              Fiber.current._publishComputation = currentComputation;\n              try {\n                return callback.apply(null, args);\n              } finally {\n                Fiber.current._publishComputation = previousPublishComputation;\n              }\n            } else {\n              return callback.apply(null, args);\n            }\n          };\n        })(callbackName, callback);\n      }\n    }\n  }\n  return callbacks;\n};\n\noriginalObserveChanges = MongoInternals.Connection.prototype._observeChanges;\n\nMongoInternals.Connection.prototype._observeChanges = function(cursorDescription, ordered, callbacks) {\n  var handle, initializing;\n  initializing = true;\n  callbacks = wrapCallbacks(callbacks, {\n    initializing: initializing\n  });\n  handle = originalObserveChanges.call(this, cursorDescription, ordered, callbacks);\n  initializing = false;\n  return handle;\n};\n\noriginalLocalCollectionCursorObserveChanges = LocalCollection.Cursor.prototype.observeChanges;\n\nLocalCollection.Cursor.prototype.observeChanges = function(options) {\n  var handle, initializing;\n  initializing = true;\n  options = wrapCallbacks(options, {\n    initializing: initializing\n  });\n  handle = originalLocalCollectionCursorObserveChanges.call(this, options);\n  initializing = false;\n  return handle;\n};\n\nextendPublish(function(name, publishFunction, options) {\n  var newPublishFunction;\n  newPublishFunction = function(...args) {\n    var allCollectionNames, collectionNames, documents, handles, oldDocuments, originalAdded, originalReady, publish, ready, result;\n    publish = this;\n    oldDocuments = {};\n    documents = {};\n    allCollectionNames = {};\n    publish._currentComputation = function() {\n      if (Tracker.active) {\n        return Tracker.currentComputation;\n      } else {\n        // Computation can also be passed through current fiber in the case the \"added\" method is called\n        // from the observeChanges callback from an observeChanges called inside a reactive context.\n        return Fiber.current._publishComputation;\n      }\n      return null;\n    };\n    publish._installCallbacks = function() {\n      var computation;\n      computation = this._currentComputation();\n      if (!computation) {\n        return;\n      }\n      if (!computation._publishOnStopSet) {\n        computation._publishOnStopSet = true;\n        computation.onStop(() => {\n          delete oldDocuments[computation._id];\n          return delete documents[computation._id];\n        });\n      }\n      if (!computation._publishAfterRunSet) {\n        computation._publishAfterRunSet = true;\n        computation.afterRun(() => {\n          // We remove those which are not published anymore.\n          iterateObjectOrMapKeys(this._documents, (collectionName) => {\n            var computationId, currentComputationAddedDocumentIds, currentlyPublishedDocumentIds, docs, i, id, len, otherComputationsAddedDocumentsIds, otherComputationsPreviouslyAddedDocumentsIds, ref, ref1, results;\n            if (this._documents instanceof Map) {\n              currentlyPublishedDocumentIds = Array.from(this._documents.get(collectionName));\n            } else {\n              currentlyPublishedDocumentIds = _.keys(this._documents[collectionName] || {});\n            }\n            currentComputationAddedDocumentIds = _.keys(((ref = documents[computation._id]) != null ? ref[collectionName] : void 0) || {});\n            // If afterRun for other autoruns in the publish function have not yet run, we have to look in \"documents\" as well.\n            otherComputationsAddedDocumentsIds = _.union(...((function() {\n              var results;\n              results = [];\n              for (computationId in documents) {\n                docs = documents[computationId];\n                if (computationId !== `${computation._id}`) {\n                  results.push(_.keys(docs[collectionName] || {}));\n                }\n              }\n              return results;\n            })()));\n            // But after afterRun, \"documents\" is empty to be ready for next rerun of the computation, so we look into \"oldDocuments\".\n            otherComputationsPreviouslyAddedDocumentsIds = _.union(...((function() {\n              var results;\n              results = [];\n              for (computationId in oldDocuments) {\n                docs = oldDocuments[computationId];\n                if (computationId !== `${computation._id}`) {\n                  results.push(_.keys(docs[collectionName] || {}));\n                }\n              }\n              return results;\n            })()));\n            ref1 = _.difference(currentlyPublishedDocumentIds, currentComputationAddedDocumentIds, otherComputationsAddedDocumentsIds, otherComputationsPreviouslyAddedDocumentsIds);\n            // We ignore IDs found in both otherComputationsAddedDocumentsIds and otherComputationsPreviouslyAddedDocumentsIds\n            // which might ignore more IDs then necessary (an ID might be previously added which has not been added in this\n            // iteration) but this is OK because in afterRun of other computations this will be corrected and documents\n            // with those IDs removed.\n            results = [];\n            for (i = 0, len = ref1.length; i < len; i++) {\n              id = ref1[i];\n              results.push(this.removed(collectionName, this._idFilter.idParse(id)));\n            }\n            return results;\n          });\n          computation.beforeRun(() => {\n            oldDocuments[computation._id] = documents[computation._id] || {};\n            return documents[computation._id] = {};\n          });\n          return computation._publishAfterRunSet = false;\n        });\n        computation._trackerInstance.requireFlush();\n      }\n    };\n    originalAdded = publish.added;\n    publish.added = function(collectionName, id, fields) {\n      var _documents, currentComputation, dataByKey, oldFields, ref, ref1, ref2, ref3, ref4, ref5, stringId;\n      stringId = this._idFilter.idStringify(id);\n      this._installCallbacks();\n      currentComputation = this._currentComputation();\n      if (currentComputation) {\n        Meteor._ensure(documents, currentComputation._id, collectionName)[stringId] = true;\n      }\n      // If document as already present in publish then we call changed to send updated fields (Meteor sends only a diff).\n      // This can hide some errors in publish functions if they one calls \"added\" on an existing document and we could\n      // make it so that this behavior works only inside reactive computation (if \"currentComputation\" is set), but we\n      // can also make it so that publish function tries to do something smarter (sending a diff) in all cases, as we do.\n      if ((this._documents instanceof Map && ((ref = this._documents.get(collectionName)) != null ? ref.has(stringId) : void 0)) || ((ref1 = this._documents[collectionName]) != null ? ref1[stringId] : void 0)) {\n        oldFields = {};\n        // If some field existed before, but does not exist anymore, we have to remove it by calling \"changed\"\n        // with value set to \"undefined\". So we look into current session's state and see which fields are currently\n        // known and create an object of same fields, just all values set to \"undefined\". We then override some fields\n        // with new values. Only top-level fields matter.\n        _documents = ((ref2 = this._session) != null ? (ref3 = ref2.getCollectionView(collectionName)) != null ? ref3.documents : void 0 : void 0) || {};\n        if (_documents instanceof Map) {\n          dataByKey = ((ref4 = _documents.get(stringId)) != null ? ref4.dataByKey : void 0) || {};\n        } else {\n          dataByKey = (_documents != null ? (ref5 = _documents[stringId]) != null ? ref5.dataByKey : void 0 : void 0) || {};\n        }\n        iterateObjectOrMapKeys(dataByKey, (field) => {\n          return oldFields[field] = void 0;\n        });\n        return this.changed(collectionName, id, _.extend(oldFields, fields));\n      } else {\n        return originalAdded.call(this, collectionName, id, fields);\n      }\n    };\n    ready = false;\n    originalReady = publish.ready;\n    publish.ready = function() {\n      this._installCallbacks();\n      if (!ready) {\n        // Mark it as ready only the first time.\n        originalReady.call(this);\n      }\n      ready = true;\n    };\n    // To return nothing.\n    handles = [];\n    // This autorun is nothing special, just that it makes sure handles are stopped when publish stops,\n    // and that you can return cursors from the function which would be automatically published.\n    publish.autorun = function(runFunc) {\n      var handle;\n      handle = Tracker.autorun(function(computation) {\n        var collectionNames, error, result;\n        computation.onInvalidate(function() {\n          return delete allCollectionNames[computation._id];\n        });\n        try {\n          result = runFunc.call(publish, computation);\n        } catch (error1) {\n          error = error1;\n          computation.stop();\n          if (computation.firstRun) {\n            throw error;\n          } else {\n            publish.error(error);\n            return;\n          }\n        }\n        collectionNames = getCollectionNames(result);\n        allCollectionNames[computation._id] = collectionNames;\n        if (!checkNames(publish, allCollectionNames, `${computation._id}`, collectionNames)) {\n          computation.stop();\n          return;\n        }\n        // Specially handle if computation has been returned.\n        if (result instanceof Tracker.Computation) {\n          if (publish._isDeactivated()) {\n            return result.stop();\n          } else {\n            return handles.push(result);\n          }\n        } else {\n          if (!publish._isDeactivated()) {\n            return publish._publishHandlerResult(result);\n          }\n        }\n      });\n      if (publish._isDeactivated()) {\n        handle.stop();\n      } else {\n        handles.push(handle);\n      }\n      return handle;\n    };\n    publish.onStop(function() {\n      var handle, results;\n      results = [];\n      while (handles.length) {\n        handle = handles.shift();\n        results.push(handle != null ? handle.stop() : void 0);\n      }\n      return results;\n    });\n    result = publishFunction.apply(publish, args);\n    collectionNames = getCollectionNames(result);\n    allCollectionNames[''] = collectionNames;\n    if (!checkNames(publish, allCollectionNames, '', collectionNames)) {\n      return;\n    }\n    // Specially handle if computation has been returned.\n    if (result instanceof Tracker.Computation) {\n      if (publish._isDeactivated()) {\n        result.stop();\n      } else {\n        handles.push(result);\n      }\n    } else {\n      // Do not return anything.\n      return result;\n    }\n  };\n  return [name, newPublishFunction, options];\n});\n"]}
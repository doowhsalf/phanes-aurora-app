{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_fiber-utils/src/meteor-server.coffee","meteor://ðŸ’»app/packages/peerlibrary_fiber-utils/src/base.coffee","meteor://ðŸ’»app/packages/peerlibrary_fiber-utils/src/fence.coffee","meteor://ðŸ’»app/src/fence.coffee","meteor://ðŸ’»app/packages/peerlibrary_fiber-utils/src/server.coffee","meteor://ðŸ’»app/src/server.coffee"],"names":["module","export","FiberUtils","fiberUtils","Fiber","link","default","v","Future","require","constructor","OrderedFence","_","assert","indexOf","allowRecursive","allowNested","breakDeadlocks","_futures","_currentFiber","enter","base","base1","dependedFiber","future","node","ownFuture","queue","visited","current","Error","_guardsActive","_dependencies","push","shift","call","without","console","warn","concat","isEmpty","length","wait","exit","topLevel","ref","return","isInUse","exports","prototype","sleep","ms","setTimeout","wrap","f","scope","args","apply","in","handleErrors","error","error1","run","ensure","synchronize","guardObject","uniqueId","options","guards","_guards"],"mappings":"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","file":"/packages/peerlibrary_fiber-utils.js","sourcesContent":["{FiberUtils} = require './server'\n\nimport Fiber from 'fibers'\nimport Future from 'fibers/future'\n\nfiberUtils = new FiberUtils Fiber, Future\n\nexport {fiberUtils as FiberUtils}\n","export class FiberUtils\n  constructor: (@Fiber, @Future) ->\n","_ = require 'underscore'\nassert = require 'assert'\n\nclass OrderedFence\n  constructor: (@Fiber, @Future, {@allowRecursive, @allowNested, @breakDeadlocks}) ->\n    @allowRecursive ?= true\n    @allowNested ?= true\n    @breakDeadlocks ?= true\n\n    # A chain of futures to enforce order.\n    @_futures = []\n    # Fiber that is currently executing the guarded section.\n    @_currentFiber = null\n\n  enter: ->\n    if @Fiber.current is @_currentFiber\n      # We allow to reenter the guarded section from the current fiber. We must not establish\n      # a dependency in this case as this would cause a deadlock.\n      throw new Error \"Recursive reentry of guarded section within the same fiber not allowed.\" unless @allowRecursive\n\n      return false\n\n    if @Fiber.current._guardsActive > 0 and not @allowNested\n      # By default we allow nested guards, but that leads to the possibility of deadlock occurring.\n      throw new Error \"Nesting of guarded sections is not allowed.\"\n\n    # Track dependencies.\n    dependedFiber = null\n    if @_currentFiber\n      @Fiber.current._dependencies ?= []\n      @Fiber.current._dependencies.push @_currentFiber\n      dependedFiber = @_currentFiber\n\n      # Search for cycles.\n      visited = []\n      queue = [@Fiber.current]\n      loop\n        node = queue.shift()\n        break unless node\n\n        if node in visited\n          if @breakDeadlocks\n            # Remove our dependency.\n            @Fiber.current._dependencies = _.without @Fiber.current._dependencies, @_currentFiber\n            # Prevent deadlock.\n            throw new Error \"Dependency cycle detected between guarded sections.\"\n\n          console.warn \"Dependency cycle detected between guarded sections. Deadlock not broken.\"\n          break\n\n        visited.push node\n        queue = queue.concat node._dependencies\n      # Free references to fibers.\n      queue = null\n      visited = null\n\n    future = null\n    future = @_futures[@_futures.length - 1] unless _.isEmpty @_futures\n    # Establish a new future so others may depend on us.\n    ownFuture = new @Future()\n    @_futures.push ownFuture\n    # Depend on any futures before us.\n    future?.wait()\n    # Remove dependency.\n    @Fiber.current._dependencies = _.without @Fiber.current._dependencies, dependedFiber if dependedFiber\n    # When we start executing, there can only be one outstanding future.\n    assert @_futures[0] is ownFuture\n    assert not @_currentFiber\n    # Store current fiber.\n    @_currentFiber = @Fiber.current\n    @_currentFiber._guardsActive ?= 0\n    @_currentFiber._guardsActive++\n\n    true\n\n  exit: (topLevel) ->\n    return unless topLevel\n\n    # Reset current fiber.\n    assert @_currentFiber._guardsActive > 0\n    @_currentFiber._guardsActive--\n    @_currentFiber = null\n    # The first future is resolved.\n    @_futures.shift()?.return()\n\n  isInUse: ->\n    @_futures.length > 0\n\nmodule.exports = {\n  OrderedFence\n}\n","var OrderedFence, _, assert,\n  indexOf = [].indexOf;\n\n_ = require('underscore');\n\nassert = require('assert');\n\nOrderedFence = class OrderedFence {\n  constructor(Fiber, Future, {allowRecursive, allowNested, breakDeadlocks}) {\n    this.Fiber = Fiber;\n    this.Future = Future;\n    this.allowRecursive = allowRecursive;\n    this.allowNested = allowNested;\n    this.breakDeadlocks = breakDeadlocks;\n    if (this.allowRecursive == null) {\n      this.allowRecursive = true;\n    }\n    if (this.allowNested == null) {\n      this.allowNested = true;\n    }\n    if (this.breakDeadlocks == null) {\n      this.breakDeadlocks = true;\n    }\n    // A chain of futures to enforce order.\n    this._futures = [];\n    // Fiber that is currently executing the guarded section.\n    this._currentFiber = null;\n  }\n\n  enter() {\n    var base, base1, dependedFiber, future, node, ownFuture, queue, visited;\n    if (this.Fiber.current === this._currentFiber) {\n      if (!this.allowRecursive) {\n        // We allow to reenter the guarded section from the current fiber. We must not establish\n        // a dependency in this case as this would cause a deadlock.\n        throw new Error(\"Recursive reentry of guarded section within the same fiber not allowed.\");\n      }\n      return false;\n    }\n    if (this.Fiber.current._guardsActive > 0 && !this.allowNested) {\n      // By default we allow nested guards, but that leads to the possibility of deadlock occurring.\n      throw new Error(\"Nesting of guarded sections is not allowed.\");\n    }\n    // Track dependencies.\n    dependedFiber = null;\n    if (this._currentFiber) {\n      if ((base = this.Fiber.current)._dependencies == null) {\n        base._dependencies = [];\n      }\n      this.Fiber.current._dependencies.push(this._currentFiber);\n      dependedFiber = this._currentFiber;\n      // Search for cycles.\n      visited = [];\n      queue = [this.Fiber.current];\n      while (true) {\n        node = queue.shift();\n        if (!node) {\n          break;\n        }\n        if (indexOf.call(visited, node) >= 0) {\n          if (this.breakDeadlocks) {\n            // Remove our dependency.\n            this.Fiber.current._dependencies = _.without(this.Fiber.current._dependencies, this._currentFiber);\n            // Prevent deadlock.\n            throw new Error(\"Dependency cycle detected between guarded sections.\");\n          }\n          console.warn(\"Dependency cycle detected between guarded sections. Deadlock not broken.\");\n          break;\n        }\n        visited.push(node);\n        queue = queue.concat(node._dependencies);\n      }\n      // Free references to fibers.\n      queue = null;\n      visited = null;\n    }\n    future = null;\n    if (!_.isEmpty(this._futures)) {\n      future = this._futures[this._futures.length - 1];\n    }\n    // Establish a new future so others may depend on us.\n    ownFuture = new this.Future();\n    this._futures.push(ownFuture);\n    // Depend on any futures before us.\n    if (future != null) {\n      future.wait();\n    }\n    if (dependedFiber) {\n      // Remove dependency.\n      this.Fiber.current._dependencies = _.without(this.Fiber.current._dependencies, dependedFiber);\n    }\n    // When we start executing, there can only be one outstanding future.\n    assert(this._futures[0] === ownFuture);\n    assert(!this._currentFiber);\n    // Store current fiber.\n    this._currentFiber = this.Fiber.current;\n    if ((base1 = this._currentFiber)._guardsActive == null) {\n      base1._guardsActive = 0;\n    }\n    this._currentFiber._guardsActive++;\n    return true;\n  }\n\n  exit(topLevel) {\n    var ref;\n    if (!topLevel) {\n      return;\n    }\n    // Reset current fiber.\n    assert(this._currentFiber._guardsActive > 0);\n    this._currentFiber._guardsActive--;\n    this._currentFiber = null;\n    // The first future is resolved.\n    return (ref = this._futures.shift()) != null ? ref.return() : void 0;\n  }\n\n  isInUse() {\n    return this._futures.length > 0;\n  }\n\n};\n\nmodule.exports = {OrderedFence};\n","import {FiberUtils} from './base'\nimport {OrderedFence} from './fence'\n\nFiberUtils::sleep = (ms) ->\n  future = new @Future()\n  setTimeout ->\n    future.return()\n  ,\n    ms\n  future.wait()\n  return\n\nFiberUtils::wrap = (f, scope=null) ->\n  (args...) =>\n    @Future.wrap(f).apply(scope, args).wait()\n\nFiberUtils::in = (f, scope=null, handleErrors=null) ->\n  (args...) =>\n    if @Fiber.current\n      try\n        f.apply(scope, args)\n      catch error\n        if handleErrors\n          handleErrors.call scope, error\n        else\n          throw error\n    else\n      new @Fiber(->\n        try\n          f.apply(scope, args)\n        catch error\n          if handleErrors\n            handleErrors.call scope, error\n          else\n            throw error\n      ).run()\n\n    # Function cannot return a value when not already running\n    # inside a Fiber, so let us not return a value at all.\n    return\n\nFiberUtils::ensure = (f, scope=null, handleErrors=null) ->\n  @in(f, scope, handleErrors)()\n\n  # Function cannot return a value when not already running\n  # inside a Fiber, so let us not return a value at all.\n  return\n\nFiberUtils::synchronize = (guardObject, uniqueId, f, options={}) ->\n  # Use the guard object to determine whether we have reentered.\n  guards = guardObject._guards ?= {}\n  guards[uniqueId] ?= new OrderedFence @Fiber, @Future, options\n  topLevel = guards[uniqueId].enter()\n\n  try\n    return f()\n  finally\n    guards[uniqueId].exit topLevel\n    delete guards[uniqueId] if uniqueId of guards and not guards[uniqueId].isInUse()\n\nexport {FiberUtils}\n","import {\n  FiberUtils\n} from './base';\n\nimport {\n  OrderedFence\n} from './fence';\n\nFiberUtils.prototype.sleep = function(ms) {\n  var future;\n  future = new this.Future();\n  setTimeout(function() {\n    return future.return();\n  }, ms);\n  future.wait();\n};\n\nFiberUtils.prototype.wrap = function(f, scope = null) {\n  return (...args) => {\n    return this.Future.wrap(f).apply(scope, args).wait();\n  };\n};\n\nFiberUtils.prototype.in = function(f, scope = null, handleErrors = null) {\n  return (...args) => {\n    var error;\n    if (this.Fiber.current) {\n      try {\n        f.apply(scope, args);\n      } catch (error1) {\n        error = error1;\n        if (handleErrors) {\n          handleErrors.call(scope, error);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      new this.Fiber(function() {\n        try {\n          return f.apply(scope, args);\n        } catch (error1) {\n          error = error1;\n          if (handleErrors) {\n            return handleErrors.call(scope, error);\n          } else {\n            throw error;\n          }\n        }\n      }).run();\n    }\n  };\n};\n\n// Function cannot return a value when not already running\n// inside a Fiber, so let us not return a value at all.\nFiberUtils.prototype.ensure = function(f, scope = null, handleErrors = null) {\n  this.in(f, scope, handleErrors)();\n};\n\n// Function cannot return a value when not already running\n// inside a Fiber, so let us not return a value at all.\nFiberUtils.prototype.synchronize = function(guardObject, uniqueId, f, options = {}) {\n  var guards, topLevel;\n  // Use the guard object to determine whether we have reentered.\n  guards = guardObject._guards != null ? guardObject._guards : guardObject._guards = {};\n  if (guards[uniqueId] == null) {\n    guards[uniqueId] = new OrderedFence(this.Fiber, this.Future, options);\n  }\n  topLevel = guards[uniqueId].enter();\n  try {\n    return f();\n  } finally {\n    guards[uniqueId].exit(topLevel);\n    if (uniqueId in guards && !guards[uniqueId].isInUse()) {\n      delete guards[uniqueId];\n    }\n  }\n};\n\nexport {\n  FiberUtils\n};\n"]}
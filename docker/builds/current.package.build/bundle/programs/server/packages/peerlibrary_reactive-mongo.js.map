{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_reactive-mongo/server.coffee","meteor://ðŸ’»app/server.coffee"],"names":["MeteorCursor","callbacksOrdered","callbacksUnordered","i","len","method","originalCount","originalExists","originalObserveChanges","ref","Object","getPrototypeOf","MongoInternals","defaultRemoteCollectionDriver","mongo","find","constructor","prototype","observeChanges","count","exists","_isReactive","_cursorDescription","options","reactive","_depend","changers","dependency","fnName","initializing","Tracker","active","Dependency","depend","length","changed","handle","call","onInvalidate","stop","addedBefore","removed","movedBefore","added","originalMethod","args","callbacks","ordered","sort","apply"],"mappings":"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","file":"/packages/peerlibrary_reactive-mongo.js","sourcesContent":["MeteorCursor = Object.getPrototypeOf(MongoInternals.defaultRemoteCollectionDriver().mongo.find()).constructor\n\noriginalObserveChanges = MeteorCursor::observeChanges\noriginalCount = MeteorCursor::count\n\n# This is a PeerDB extension. It might not exist if the package is used without PeerDB.\n# But we defined a week dependency on PeerDB so that it is loaded before this package\n# to that PeerDB adds this extension before we get here.\noriginalExists = MeteorCursor::exists\n\nMeteorCursor::_isReactive = ->\n  # By default we make all cursors reactive. But you can\n  # still disable that, the same as on the client.\n  @_cursorDescription.options.reactive ? true\n\nMeteorCursor::_depend = (changers) ->\n  return unless Tracker.active\n\n  dependency = new Tracker.Dependency()\n  dependency.depend()\n\n  # On server side observe does not have _suppress_initial,\n  # so we are skipping initial documents manually.\n  initializing = true\n\n  options = {}\n  for fnName in ['added', 'changed', 'removed', 'addedBefore', 'movedBefore'] when changers[fnName]\n    options[fnName] = ->\n      dependency.changed() unless initializing\n\n  # observeChanges will stop() when this computation is invalidated.\n  @observeChanges options\n\n  initializing = false\n\nMeteorCursor::observeChanges = (options) ->\n  handle = originalObserveChanges.call @, options\n  if Tracker.active and @_isReactive()\n    Tracker.onInvalidate =>\n      handle.stop()\n  handle\n\ncallbacksOrdered =\n  addedBefore: true\n  removed: true\n  changed: true\n  movedBefore: true\n\ncallbacksUnordered =\n  added: true\n  changed: true\n  removed: true\n\nfor method in ['forEach', 'map', 'fetch']\n  do (method) ->\n    originalMethod = MeteorCursor::[method]\n    MeteorCursor::[method] = (args...) ->\n      if @_isReactive()\n        {sort, ordered} = @_cursorDescription.options\n        if ordered?\n          callbacks = if ordered then callbacksOrdered else callbacksUnordered\n        else\n          callbacks = if !!sort then callbacksOrdered else callbacksUnordered\n        @_depend callbacks\n\n      originalMethod.apply @, args\n\nMeteorCursor::count = (args...) ->\n  if @_isReactive()\n    @_depend\n      added: true\n      removed: true\n\n  originalCount.apply @, args\n\nif originalExists\n  MeteorCursor::exists = (args...) ->\n    if @_isReactive()\n      @_depend\n        added: true\n        removed: true\n\n    originalExists.apply @, args\n","var MeteorCursor, callbacksOrdered, callbacksUnordered, i, len, method, originalCount, originalExists, originalObserveChanges, ref;\n\nMeteorCursor = Object.getPrototypeOf(MongoInternals.defaultRemoteCollectionDriver().mongo.find()).constructor;\n\noriginalObserveChanges = MeteorCursor.prototype.observeChanges;\n\noriginalCount = MeteorCursor.prototype.count;\n\n// This is a PeerDB extension. It might not exist if the package is used without PeerDB.\n// But we defined a week dependency on PeerDB so that it is loaded before this package\n// to that PeerDB adds this extension before we get here.\noriginalExists = MeteorCursor.prototype.exists;\n\nMeteorCursor.prototype._isReactive = function() {\n  var ref;\n  // By default we make all cursors reactive. But you can\n  // still disable that, the same as on the client.\n  return (ref = this._cursorDescription.options.reactive) != null ? ref : true;\n};\n\nMeteorCursor.prototype._depend = function(changers) {\n  var dependency, fnName, i, initializing, len, options, ref;\n  if (!Tracker.active) {\n    return;\n  }\n  dependency = new Tracker.Dependency();\n  dependency.depend();\n  // On server side observe does not have _suppress_initial,\n  // so we are skipping initial documents manually.\n  initializing = true;\n  options = {};\n  ref = ['added', 'changed', 'removed', 'addedBefore', 'movedBefore'];\n  for (i = 0, len = ref.length; i < len; i++) {\n    fnName = ref[i];\n    if (changers[fnName]) {\n      options[fnName] = function() {\n        if (!initializing) {\n          return dependency.changed();\n        }\n      };\n    }\n  }\n  // observeChanges will stop() when this computation is invalidated.\n  this.observeChanges(options);\n  return initializing = false;\n};\n\nMeteorCursor.prototype.observeChanges = function(options) {\n  var handle;\n  handle = originalObserveChanges.call(this, options);\n  if (Tracker.active && this._isReactive()) {\n    Tracker.onInvalidate(() => {\n      return handle.stop();\n    });\n  }\n  return handle;\n};\n\ncallbacksOrdered = {\n  addedBefore: true,\n  removed: true,\n  changed: true,\n  movedBefore: true\n};\n\ncallbacksUnordered = {\n  added: true,\n  changed: true,\n  removed: true\n};\n\nref = ['forEach', 'map', 'fetch'];\nfor (i = 0, len = ref.length; i < len; i++) {\n  method = ref[i];\n  (function(method) {\n    var originalMethod;\n    originalMethod = MeteorCursor.prototype[method];\n    return MeteorCursor.prototype[method] = function(...args) {\n      var callbacks, ordered, sort;\n      if (this._isReactive()) {\n        ({sort, ordered} = this._cursorDescription.options);\n        if (ordered != null) {\n          callbacks = ordered ? callbacksOrdered : callbacksUnordered;\n        } else {\n          callbacks = !!sort ? callbacksOrdered : callbacksUnordered;\n        }\n        this._depend(callbacks);\n      }\n      return originalMethod.apply(this, args);\n    };\n  })(method);\n}\n\nMeteorCursor.prototype.count = function(...args) {\n  if (this._isReactive()) {\n    this._depend({\n      added: true,\n      removed: true\n    });\n  }\n  return originalCount.apply(this, args);\n};\n\nif (originalExists) {\n  MeteorCursor.prototype.exists = function(...args) {\n    if (this._isReactive()) {\n      this._depend({\n        added: true,\n        removed: true\n      });\n    }\n    return originalExists.apply(this, args);\n  };\n}\n"]}
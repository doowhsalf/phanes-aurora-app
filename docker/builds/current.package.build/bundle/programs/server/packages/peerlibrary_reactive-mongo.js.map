{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_reactive-mongo/server.coffee","meteor://ðŸ’»app/server.coffee"],"names":["MeteorCursor","callbacksOrdered","callbacksUnordered","i","len","method","originalCount","originalExists","originalObserveChanges","ref","Object","getPrototypeOf","MongoInternals","defaultRemoteCollectionDriver","mongo","find","constructor","prototype","observeChanges","count","exists","_isReactive","_cursorDescription","options","reactive","_depend","changers","callback","dependency","fnName","initializing","Tracker","active","Dependency","depend","length","changed","nonMutatingCallbacks","callbacks","handle","call","onInvalidate","stop","addedBefore","removed","movedBefore","added","originalMethod","args","ordered","sort","apply"],"mappings":"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","file":"/packages/peerlibrary_reactive-mongo.js","sourcesContent":["MeteorCursor = Object.getPrototypeOf(MongoInternals.defaultRemoteCollectionDriver().mongo.find()).constructor\n\noriginalObserveChanges = MeteorCursor::observeChanges\noriginalCount = MeteorCursor::count\n\n# This is a PeerDB extension. It might not exist if the package is used without PeerDB.\n# But we defined a week dependency on PeerDB so that it is loaded before this package\n# to that PeerDB adds this extension before we get here.\noriginalExists = MeteorCursor::exists\n\nMeteorCursor::_isReactive = ->\n  # By default we make all cursors reactive. But you can\n  # still disable that, the same as on the client.\n  @_cursorDescription.options.reactive ? true\n\nMeteorCursor::_depend = (changers) ->\n  return unless Tracker.active\n\n  dependency = new Tracker.Dependency()\n  dependency.depend()\n\n  # On server side observe does not have _suppress_initial,\n  # so we are skipping initial documents manually.\n  initializing = true\n\n  callback = {}\n  for fnName in ['added', 'changed', 'removed', 'addedBefore', 'movedBefore'] when changers[fnName]\n    callback[fnName] = ->\n      dependency.changed() unless initializing\n\n  # observeChanges will stop() when this computation is invalidated.\n  @observeChanges callback, {nonMutatingCallbacks: true}\n\n  initializing = false\n\nMeteorCursor::observeChanges = (callbacks, options = {}) ->\n  handle = originalObserveChanges.call @, callbacks, options\n  if Tracker.active and @_isReactive()\n    Tracker.onInvalidate =>\n      handle.stop()\n  handle\n\ncallbacksOrdered =\n  addedBefore: true\n  removed: true\n  changed: true\n  movedBefore: true\n\ncallbacksUnordered =\n  added: true\n  changed: true\n  removed: true\n\nfor method in ['forEach', 'map', 'fetch']\n  do (method) ->\n    originalMethod = MeteorCursor::[method]\n    MeteorCursor::[method] = (args...) ->\n      if @_isReactive()\n        {sort, ordered} = @_cursorDescription.options\n        if ordered?\n          callbacks = if ordered then callbacksOrdered else callbacksUnordered\n        else\n          callbacks = if !!sort then callbacksOrdered else callbacksUnordered\n        @_depend callbacks\n\n      originalMethod.apply @, args\n\nMeteorCursor::count = (args...) ->\n  if @_isReactive()\n    @_depend\n      added: true\n      removed: true\n\n  originalCount.apply @, args\n\nif originalExists\n  MeteorCursor::exists = (args...) ->\n    if @_isReactive()\n      @_depend\n        added: true\n        removed: true\n\n    originalExists.apply @, args\n","var MeteorCursor, callbacksOrdered, callbacksUnordered, i, len, method, originalCount, originalExists, originalObserveChanges, ref;\n\nMeteorCursor = Object.getPrototypeOf(MongoInternals.defaultRemoteCollectionDriver().mongo.find()).constructor;\n\noriginalObserveChanges = MeteorCursor.prototype.observeChanges;\n\noriginalCount = MeteorCursor.prototype.count;\n\n// This is a PeerDB extension. It might not exist if the package is used without PeerDB.\n// But we defined a week dependency on PeerDB so that it is loaded before this package\n// to that PeerDB adds this extension before we get here.\noriginalExists = MeteorCursor.prototype.exists;\n\nMeteorCursor.prototype._isReactive = function() {\n  var ref;\n  // By default we make all cursors reactive. But you can\n  // still disable that, the same as on the client.\n  return (ref = this._cursorDescription.options.reactive) != null ? ref : true;\n};\n\nMeteorCursor.prototype._depend = function(changers) {\n  var callback, dependency, fnName, i, initializing, len, ref;\n  if (!Tracker.active) {\n    return;\n  }\n  dependency = new Tracker.Dependency();\n  dependency.depend();\n  // On server side observe does not have _suppress_initial,\n  // so we are skipping initial documents manually.\n  initializing = true;\n  callback = {};\n  ref = ['added', 'changed', 'removed', 'addedBefore', 'movedBefore'];\n  for (i = 0, len = ref.length; i < len; i++) {\n    fnName = ref[i];\n    if (changers[fnName]) {\n      callback[fnName] = function() {\n        if (!initializing) {\n          return dependency.changed();\n        }\n      };\n    }\n  }\n  // observeChanges will stop() when this computation is invalidated.\n  this.observeChanges(callback, {\n    nonMutatingCallbacks: true\n  });\n  return initializing = false;\n};\n\nMeteorCursor.prototype.observeChanges = function(callbacks, options = {}) {\n  var handle;\n  handle = originalObserveChanges.call(this, callbacks, options);\n  if (Tracker.active && this._isReactive()) {\n    Tracker.onInvalidate(() => {\n      return handle.stop();\n    });\n  }\n  return handle;\n};\n\ncallbacksOrdered = {\n  addedBefore: true,\n  removed: true,\n  changed: true,\n  movedBefore: true\n};\n\ncallbacksUnordered = {\n  added: true,\n  changed: true,\n  removed: true\n};\n\nref = ['forEach', 'map', 'fetch'];\nfor (i = 0, len = ref.length; i < len; i++) {\n  method = ref[i];\n  (function(method) {\n    var originalMethod;\n    originalMethod = MeteorCursor.prototype[method];\n    return MeteorCursor.prototype[method] = function(...args) {\n      var callbacks, ordered, sort;\n      if (this._isReactive()) {\n        ({sort, ordered} = this._cursorDescription.options);\n        if (ordered != null) {\n          callbacks = ordered ? callbacksOrdered : callbacksUnordered;\n        } else {\n          callbacks = !!sort ? callbacksOrdered : callbacksUnordered;\n        }\n        this._depend(callbacks);\n      }\n      return originalMethod.apply(this, args);\n    };\n  })(method);\n}\n\nMeteorCursor.prototype.count = function(...args) {\n  if (this._isReactive()) {\n    this._depend({\n      added: true,\n      removed: true\n    });\n  }\n  return originalCount.apply(this, args);\n};\n\nif (originalExists) {\n  MeteorCursor.prototype.exists = function(...args) {\n    if (this._isReactive()) {\n      this._depend({\n        added: true,\n        removed: true\n      });\n    }\n    return originalExists.apply(this, args);\n  };\n}\n"]}